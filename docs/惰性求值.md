## $\bot$ bottom

在讨论函数式编程语义时，使用 $\bot$ 表示计算不可能完成的结果。在 $\lambda$ 表达式式中，不会被化简为  $\beta-nf$  

在 Haskell 中，$\bot$ 可以是 `forever` 函数的结果，异常或者是 `undefined`

任何类型的计算都可能没有结果，在使用 `data` 关键字定义类型时，Haskell 会自动为每个类型附加一个额外的值 $\bot$

> 定义：如果一个类型的值没有 $\bot$ 则说明它是非提升的（ `unlifted` ）,如果有则说明这种类型是提升的（ `lifted` ）。

使用 `newtype` 定义类型只是相当于把一个类型的值放入一个构造器内重新命名，与 `data` 相比，`newtype` 不会引入 $\bot$

```haskell
newtype N = N Int
data D = D Int

n (N i) = 42
d (D i) = 42

-- n undefined = 42
-- d undefined = undefined
```

从严格意义上来讲：N 类型与 Int 类型是同构的，D 不是。

> 定义：在编程语言中，当且仅当 `f` $\bot = \bot$ 时，则说函数 `f` 是严格的。

C，Java 语言为严格模式，Haskell  为非严格模式。虽然在类型上来讲的 $\bot$ 值可能拥有不同的类型，如 `Just` $\bot$ 和 $\bot$​​ ，但是从语义上是不区分的。从实际计算上来将，$\bot$ 为 `Int` 类型的值，`D` $\bot$ 为 `D Int` 上一个值。由于 `Haskell` 的惰性求值，在计算 `d (D undefined)` 时返回 42，因为不必去计算 `D undefined` 中的 `undefined` 。

在 Haskell 中，如果明确需要 `data` 关键字创建类型的构造器进行严格求值，可以在类型前添加一个 `!`

```haskell
data Person = Person !String !Int
```

而 `newtype` 关键字则不可以添加 `!`

## 表达式形态和 `thunk`

> 定义：一个 $\lambda$ 表达式被称为弱首范式当且仅当它符合 $F E_1 E_2 \dots E_n $ 形式，其中 `n` 为自然数。

Haskell 在默认条件下会把一个表达式求值为弱首范式（weak head normal form），在 Haskell 中，下列几种情况，一个表达式为弱首范式。

- F 为变量（n = 0）
- F 为数据对象（常量）
- F 为抽象（匿名函数）
- F 为内嵌函数
- F 为函数，E~n~  为变量或者常量

范式则是表示为已经被完全求值的表达式（函数，变量），所有范式都属于弱首范式。



## thunk 与 严格求值

`thunk` 意为形实替换程序（也称为延迟计算），指将在计算过程中，一些函数的参数或者结果通过一段程序来表达。可以简单地把 `thunk` 看作一个未完全求得结果的表达式与求得该表达式所需的环境变量组成的函数，这个表达式与环境形成了一个无参数闭包。

在 Haskell 表达式首先被当成为一个 `thunk` 进行占位，当需要它的值时才进行 `thunk` 求值。

例子：对于 `[1..]` 表达式首先被当成一个 thunk ，当需要取出第一个元素时，该表达式变为 `thunk:thunk`，因为第一个元素可能只是进行占位，并不需要值，当明确要求第一个元素的值时，才将 thunk 进行计算，结果为 1。

在 `GHCI` 中可以使用 `:sprint` 表示出 `thunk`



## 求值策略

### 传值调用（call by value）

### 传名调用（call by name）

### 常序求值

先从左边最外侧的在不 $\lambda$ 函数定义内的式子开始化简。若是一个弱首范式表达式存在 $\beta-nf$ 则常序求值一定可以将其化简成 $\beta-nf$ 。



## 严格模式匹配和惰性模式匹配

```haskell
(&&) False b = False
(&&) True b  = b

--
(&&) False undefined -- False
```

对于上述的 `&&` 函数，当 Haskell  检测到第一个参数为 False 时，不会严格对 `&&` 第二个参数进行求值。

若是想要模式匹配时对参数进行严格求值，可以使用 `BangPatterns` 扩展

```haskell
f !x = True -- 与 f x = seq x True 等价

data Point = Point !Int !Int !Int
-- 关于所有 Point 类型的函数都会对 Point 类型的值进行严格求值
```

Haskell 也提供惰性模式匹配， 在匹配时使用 `~` 符号。

```haskell
let f (x,y) = 5 in f undefined
--
let f ~(x,y) = 5 in f undefined
```

也可以使用全局严格求值扩展：`StrictData`

```haskell
{-# LANGUAGE StrictDat #-}

data Point = Point Int Int Int -- 默认为构造器中所有元素进行严格求值

-- 也可以显示声明其为惰性求值
data Point = Point ~Int ~Int ~Int

```





















